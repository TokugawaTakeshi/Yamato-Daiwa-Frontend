extends ../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../SharedAssets/Markup/Assets.russian.pug
  include ../../../Components/Components.russian.pug


block append Metadata

  -

    HTML_PAGE_LANGUAGE = "ru";
    HTML_PAGE_TITLE = buildHTML_PageTitle("Компоненты графического пользовательского интерфейса");
    HTML_PageMetaData = {
      description: "",
      author: HTML_PAGE_AUTHOR
    };

    FAVICON_URI = "@MustBeInPublicRoot/favicon";

    styleSheetsURIs = [ "@Shared/CommonStyles", "@Layouts/TwoColumns/TwoColumnsLayout", "@Shared/ExternalComponents" ];
    scriptsURIs.endOfBody = [ "@Common" ];

    RoutingEmulator.setCurrentRoute("coreLibrary.components");

    LanguageDropDownList__YDF_DK.setLinks({
      [LanguageDropDownList__YDF_DK.supportedLanguages.english]: "#",
      [LanguageDropDownList__YDF_DK.supportedLanguages.japanese]: "#"
    });


block append SpecificContent

  article

    h1.Article-Heading1 Компоненты графического пользовательского интерфейса

    p.Article-Paragraph.
      #[+Term--YDID Компоненты графического пользовательского интерфейса] появились в #[+ImportantEntity--YDID YDF] начиная
        с версии #[+ImportantEntity--YDID 2.0.0].
      В сравнении с другими #[+Term--YDID UX/UX-фреймворками], можно выделить следующие особенности #[+ImportantEntity--YDID YDF]:

    ol.Article-OrderedList

      li

        | Разметка

        ol

          li.
            Разметка компонентов поставляются в виде
              #[+Link--YDF({ unendorsedExternalURI: "sharedExternalLinks.pug.homePage.mixins" }).Article-Link Pug-примесей].
            Таким образом, пока #[+Term--YDID примесь] не вызвана, выходного HTML-кода не прибавится.

          li.
            Параметры примесей проходят валидацию с подробным отчётом, благодаря которому можно будет исправить ошибку
              не обращаясь к документации при понимании английского технического текста со словарём.
            В том числе и для этого было необходимо интегрировать в Pug-код #[+ImportantEntity--YDID YDF] функциональность
              библиотеки
              #[+Link--YDF({ unendorsedExternalURI: "sharedExternalLinks.YDEE.top" }).Article-Link @yamato-daiwa/es-extensions].

          li.
            Разметка компонентов написана с учётом доступности и поисковой оптимизации, однако ввиду того, что эта разметка
              инкапсулирована в Pug-примеси, пользователям #[+ImportantEntity--YDID YDF] не нужно вникать в эти детали.

      li

        | Стили

        ol

          li.
            Все стили компонентов поставляются в виде
              #[+Link--YDF({ unendorsedExternalURI: "sharedExternalLinks.stylus.homePage.mixins" }).Article-Link Stylus-примесей].
            Таким образом, пока #[+Term--YDID примесь] не вызвана, выходного CSS-кода не прибавится.

          li.
            Как и в случае с разметкой, параметры примесей проходят валидацию с подробным отчётом, благодаря которому
              можно будет исправить ошибку не обращаясь к документации при понимании английского технического текста
              со словарём.

          li.
            Возможно несколько подходов кастомизации стилей компонентов от небольшой модификации готовых стилей до полного
              самостоятельного написания стилей.
            Но даже в последнем случае #[+ImportantEntity--YDID YDF] представляет ценность, потому что помимо стилей
              от также предлагает качественную разметку и логику (TypeScript-код).

          li.
            Хотя помимо основного пакета #[+ImportantEntity--YDID YDF] предлагает адаптации для популярных фронтенд-
              фреймворков (таких как Vue), стили берутся из основного пакета #[+ImportantEntity--YDID YDF].


      li

        | Логика (TypeScript-код)

        ol

          li.
            Логика поставляется в виде TypeScript-классов с максимальной типовой безопасностью
              (без использования #[+ImportantEntity__Code--YDID any]).
            Для использования логики необходим сборщик проектов, такой как Webpack.

          li.
            В рамках объектно-ориентированного программирования, возможно создание производных классов с целью добавления
              новой функциональности.


    h2.Article-Heading2 Разметка

    h3.Article-Heading3(
      id=localizedRouting.coreLibrary.$children.components.$sections.providingOfMarkup.$anchor
    ) Подключение функциональности

    p.Article-Paragraph.
      Для того, чтобы получить доступ к Pug-примесям компонентов, нужно подключить 2 файла: Functionality.pug и
        Components.pug в указанном порядке.
      Одно это не приведёт к появлению дополнительного HTML-кода.

    //- CODE

    p.Article-Paragraph.
      Если Pug-файл унаследован от одного из шаблона страницы, предлагаемым YDF, то Functionality.pug уже подключён и
        осталось подключить только Components.pug.

    //- CODE
    //- Коммент к коду: теперь можно вызывать примеси любых компонентов, упомянутых в этой документации.

    p.Article-Paragraph.
      Имена Pug-примесей компонентов подчиняются шаблону [ИмяКомпонента]--YDF, где #[+ImportantEntity__Code--YDID --YDF] -
        #[+Term--YDID вендорный постфикс], добавленный с целью значительного уменьшения вероятности возникновения конфликта имён.
      Например, компоненту #[+SecondaryEntity--YDID Button] соответствует примесь #[+SecondaryEntity--YDID Button--YDF].

    p.Article-Paragraph.
      На этом подключение разметки завершено, однако для корректного отображения компонентов необходимо подключить стили.


    h3.Article-Heading3 Производительность при использовании в MVC-приложениях

    p.Article-Paragraph.
      Генерировать компоненты на серверной стороне в ответ на клиентские запросы не рекомендуется (за исключением
        редких случаев, когда клиент готов подождать несколько секунд).
      Смысл шаблона #[+ImportantEntity--YDID MVC] - генерация HTML-кода на основе слияния шаблона и данных, однако
        GUI-компоненты (такие как кнопки или поля вводы) в большинстве случаев будут одинаковыми вне зависимости от данных.

    p.Article-Paragraph.
      Помимо ручного редактирования HTML-кода




    h2.Article-Heading2 Стили

    h3.Article-Heading3 Подключение функциональности

    p.Article-Paragraph.
      Для того, чтобы получить доступ к Stylus-примесям компонентов, нужно подключить 2 файла: Functionality.styl и
        Components.styl в указанном порядке.
      Одно это не приведёт к появлению дополнительного CSS-кода.

    //- CODE

    p.Article-Paragraph.
      На этом подключение стилей завершено, однако для генерации CSS-кода компонентов необходимо вызывать соответствующие
        Stylus-примеси.


    h3.Article-Heading3 Генерация стилей компонентов

    p.Article-Paragraph.
      Примеси, генерирующие CSS-стили GUI-компонентов, названы в соответствии с соглашением #[+ImportantEntity__Code--YDID provide[]Styles].
      Например, для компонента Button это будет #[+ImportantEntity__Code--YDID provideButtonYDF_Component].

    p.Article-Paragraph.
      Способ использования этих примесей зависит от того, насколько глубоко Вы хотите переопределить стандартные стили.

    h4.Article-Heading4 Использование стилей по умолчанию
    .Article-Subheading4 Нет времени возиться со стилями, дай мне технически эстетические готовые стили, быстро!

    p.Article-Paragraph.
      Для этого достаточно вызывать соответствующую примесь без параметров.

    //- Code

    p.Article-Paragraph.
      Такой подход хорош в следующих случаях:

    ul.Article-UnorderedList
      li Создаётс я






    h3.Article-Heading3 Производительность

    p.Article-Paragraph.
      К сожалению, такие особенности как гибкая кастомизация и валидация параметров дались большими проблемами прозводительности
        при транслайлинге из Stylus в CSS.
      Каждый компонент увеличивает время транспайлинга где-то на 1 секунду, и хотя производительность вторична
        при сборке проектов, многие не готовы ждать по 10-20 секунд.
      Очевидно, что Stylus и аналогические препроцессоры на такую развитую внутреннюю логику не рассчитаны, тем не менее
        при разработке фреймворков она востребована.

    p.Article-Paragraph.
      Решение состоит в том, всё, что касается YDF-компонентов и их кастомизации собрать в отдельный CSS-файл.
      По пере работы над проектом исходный код будет меняться относительно редко.



    h2.Article-Heading2 Логика

    h3.Article-Heading3 Подключение функциональности

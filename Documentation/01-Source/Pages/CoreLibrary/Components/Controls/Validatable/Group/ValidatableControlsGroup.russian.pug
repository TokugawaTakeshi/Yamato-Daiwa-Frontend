extends ../../../../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../../../../SharedAssets/Markup/SharedAssets.russian.pug
  include ../../../../../../SharedComponents/SharedComponents.russian.pug


block append Metadata

  -

    HTML_PAGE_LANGUAGE = "ru";
    HTML_PAGE_TITLE = buildHTML_PageTitle("Validatable controls");
    HTML_PageMetaData = {
      description: "",
      author: HTML_PAGE_AUTHOR
    };

    FAVICON_URI = "@MustBeInPublicRoot/favicon";

    styleSheetsURIs = [ "@Shared/CommonStyles", "@Layouts/TwoColumns/TwoColumnsLayout", "@Shared/ExternalComponents" ];
    scriptsURIs.endOfBody = [ "@Common" ];

    RoutingEmulator.setCurrentRoute(
      "coreLibrary.$children.components.$children.controls.$children.validatable"
    );

    LanguageDropDownList__YDF_DK.setLinks({
      english: "#",
      japanese: "#"
    });


block append HeadScriptsLinks

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    h1.Article-Heading1 Группы валидирующих компонентов ввода

    p.Article-Paragraph.
      В большинстве случаев валидирущие компоненты ввода нужны в группе.
      Группу валидирущих компонентов ввода не следует путать с формой ввода.
      Группа валидирущих компонентов ввода является хотя и основным, но лишь одним из составляющих формы ввода -
        другими являются кнопка, заголовок (картинка).
      Как следует, одну и ту же группу можно применить для нескольких форм.


    h2.Article-Heading2 Примеры
    h3.Article-Heading3 Простейшая интегрированная группа валидирующих компонентв ввода

    //- TODO Gif с управлением формой
    //- TODO frame с демкой

    p.Article-Paragraph.
      В качестве простейшего примера подойдёт форма авторизации: два поля ("имя пользователя" и "пароль") и одна кнопка.
      На словах, предстоит сделать следующее:

    ol.Article-OrderedList

      li.
        Написать #[+Term--YDID разметку] и #[+Term--YDID стили].
        В случае #[+ImportantEntity--YDID YDF] можно увидеть, как будут отображаться сообщения ошибках валидации благодаря
          функциональности "симуляция состояний" (#[+ImportantEntity__Code--YDID stateSimulations]) ещё до того,
          как мы приступим к написанию логики.

      li.
        Подготовить #[+Term--YDID классы валидаций], унаследованные от #[+ImportantEntity__Code--YDID InputtedValueValidation].


      li.
        Объявить и инициализировать переменную типа #[+ImportantEntity__Code--YDID ValidatableControlsGroup].

      li.
        Установить обработчик события на кнопку отправки данных, который позволяет отправить данные лишь когда они
          валидны.

    p.Article-Paragraph.
      Мы также сделаем дополнительное сообщение на случай, если пользователь попытается отправить невалидные данные
        (включая случай оставленных незаполненными полей).
      С случае маленьких форма ввода, как в этом примере, без этого сообщения можно вполне обойтись, потому что
        оба поля ввода находятся в поле зрения пользователя и каждого из них будут отображаться собственные, более
        конкретные сообщения об ошибках.
      Но хотя этот пример и простейший, нам нужно, чтобы Вы смогли его легко масштабировать на свои случаи.

    p.Article-Paragraph.
      Асинхронную отправку данных на сервер мы эмулируем с помощью вспомогательного класса.


    +CodeViewer--YDF
      +CodeViewer-TabPanel--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript })

        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          /* --- Validations -------------------------------------------------------------------------------------------------- */
          import InputtedSignInDataValidations from "./_Partials/InputtedSignInDataValidations";

          /* --- Framework ---------------------------------------------------------------------------------------------------- */
          import {
            ValidatableControlsGroup,
            TextBox,
            Button,
            CollapsingAnimation,
            ExpandingAnimation
          } from "@yamato-daiwa/frontend";

          /* --- Utils -------------------------------------------------------------------------------------------------------- */
          import { Logger, DataSubmittingFailedError } from "@yamato-daiwa/es-extensions";
          import { getExpectedToBeSingleChildOfTemplateElement, BasicFrontEndLogger } from "@yamato-daiwa/es-extensions-browserjs";


          type InputtedData = Readonly<{
            userName: string;
            password: string;
          }>;

        +CodeViewer-Explanation--YDF
          p.Article-Paragraph.
            Этот тип нам понадобится дважды: при объявлении #[+Term--YDID переменной]
              #[+ImportantEntity__Code--YDID controlsGroup], представляющей доступ к состоянию введённых данных,
              а также при получении введённых значений при их отправке.

        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          let hasUserTriedToSubmitDataAtLeastOnce: boolean = false;

          const errorMessageMountingPoint: Comment = document.createComment("ERROR_MESSAGE_MOUNTING_POINT");
          const invalidOrOmittedDataLeftErrorMessage: HTMLElement = getExpectedToBeSingleChildOfTemplateElement({
            templateElementSelector: "#ERROR_MESSAGE_TEMPLATE",
            mustReplaceTemplateElementOnceDoneWith: errorMessageMountingPoint,
            expectedChildElementSubtype: HTMLElement
          });
        +CodeViewer-Explanation--YDF

          p.Article-Paragraph.
            Этот набор переменных нужен затем, чтобы отобразить итоговое сообщение с просьбой проверить введённые
              данные когда пользователь попытается отправить незаполненные поля либо неверно введённые значения.
            При этом что конкретно не так - будет отображено рядом с соответствующими элементами ввода.

          p.Article-Paragraph.
            Повторимся, что такое обобщающее сообщение нужно в основном для больших форм, но для того, чтобы Вы смогли
              масштабировать данный пример на свой случай, мы добавили это сообщение в пример.

          p.Article-Paragraph.
            Наконец, немного о манипуляции этим сообщением - элементом #[+ImportantEntity__Code--YDID p], обёрнутом в
              элемент #[+ImportantEntity__Code--YDID template].
            Его можно бы просто разместить после поля ввода
              (элементом с идентификатором #[ImportantEntity__Code--YDID #PASSWORD_TEXTBOX]) с помощью нативного метода
              #[+ImportantEntity__Code--YDID Element.append()].
            Однако, при таком подходе изменение расположения элементов в разметке поломает нашу логику, что непозволительно
              в высококачественной разработке.
            Чтобы этого избежать, мы захватили с помощью
              #[+ImportantEntity__Code--YDID getExpectedToBeSingleChildOfTemplateElement] элемент
              #[+ImportantEntity__Code--YDID template].
              Эта функция сразу же разворачивает дочерний элемент, а также мы дополнительно приказали ей заменить
              #[+ImportantEntity__Code--YDID template] обычном HTML-комментарием.
            Теперь при необходимости мы можем снова вмонтировать это сообщение на место комментария вне зависимости от
              его взаимного расположения с другими компонентами, а пока такой необходимости нет - сообщение об ошибке
              не будет мешаться в DOM-древе.


        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities

          const controlsGroup: ValidatableControlsGroup<InputtedData> = new ValidatableControlsGroup({

            controlsPayload: {
              userName: TextBox.pickOneBySelector<string, string, InputtedSignInDataValidations.UserName>({
                selector: "#USER_NAME_TEXTBOX",
                rawInputModifier: TextBox.RawInputModifiers.keepStringValueAsIs,
                validation: new InputtedSignInDataValidations.UserName(),
                mustActivateInvalidHighlightImmediately: false
              }).payload,
              password: TextBox.pickOneBySelector<string, string, InputtedSignInDataValidations.Password>({
                selector: "#PASSWORD_TEXTBOX",
                rawInputModifier: TextBox.RawInputModifiers.keepStringValueAsIs,
                validation: new InputtedSignInDataValidations.Password(),
                mustActivateInvalidHighlightImmediately: false
              }).payload
            },

            onHasBecomeValid(): void {
              CollapsingAnimation.animate({
                replaceWithOnComplete: errorMessageMountingPoint,
                animatedElement: invalidOrOmittedDataLeftErrorMessage,
                duration__seconds: 0.2
              });
            },

            onHasBecomeInvalid(): void {
              if (hasUserTriedToSubmitDataAtLeastOnce) {
                ExpandingAnimation.replaceNodeAndAnimate({
                  animatedElement: invalidOrOmittedDataLeftErrorMessage,
                  replacedNode: errorMessageMountingPoint,
                  duration__seconds: 0.2
                });
              }
            },

            scrollingContainerHTML_ID: "SCROLLABLE_CONTAINER"

          });

          Button.pickOneBySelector({
            selector: "#SUBMITTING_BUTTON",
            onClick(): void {

              hasUserTriedToSubmitDataAtLeastOnce = true;

              if (controlsGroup.isInvalid) {

                controlsGroup.pointOutValidationErrors();

                ExpandingAnimation.replaceNodeAndAnimate({
                  animatedElement: invalidOrOmittedDataLeftErrorMessage,
                  replacedNode: errorMessageMountingPoint,
                  duration__seconds: 0.2
                });

                return;
              }


              try {

                const inputtedData: InputtedData = controlsGroup.getExpectedToBeValidData();

                Logger.logSuccess({
                  title: "Sign in success",
                  description: "",
                  additionalData: inputtedData
                });

              } catch (error: unknown) {

                Logger.logError({
                  errorType: DataSubmittingFailedError.NAME,
                  title: DataSubmittingFailedError.localization.defaultTitle,
                  description: "",
                  occurrenceLocation: "runApplication()",
                  caughtError: error
                });

              }
            }
          });

          Logger.setImplementation(BasicFrontEndLogger);

        +CodeViewer-Explanation--YDF
          p.Article-Paragraph.
            Explanation


        +CodeViewer-PartialListing--YDF: :html_special_characters_to_html_entities
          const sampleArray: Array<string> = [ "INITIALLY_EXISTED_ELEMENT-1" ];
        +CodeViewer-Explanation--YDF
          p.Article-Paragraph.
            Explanation

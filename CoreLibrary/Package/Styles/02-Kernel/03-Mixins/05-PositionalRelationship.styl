PositionalRelationship(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      definitions: {
        required: true
      },
      contextSelector: {
        type: DataTypes.string,
        required: false
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "PositionalRelationship"
  })

  definitions = parametersObject.definitions
  referenceElementSelector = parametersObject.referenceElementSelector
  contextSelector = parametersObject.contextSelector


  iterateAssociativeArray(definitions, @(targetElementSelector, definition) {

    if (isNotNull(definition.retireFromIt) && (isNotNull(definition.retireFromIt.x) || isNotNull(definition.retireFromIt.y))) {

      // [ Example ]
      // For:
      //    targetElementSelector: "h3"
      //    contextSelector: "EmailFormatting"
      //    referenceElementSelector: "p"
      // we need:
      //    .EmailFormatting h3 + p
      elementFromWhichToRetireSelector = isNull(contextSelector) ?\
          targetElementSelector : contextSelector + " " + targetElementSelector

      /{elementFromWhichToRetireSelector} + {referenceElementSelector} {
        if (definition.retireFromIt.usePaddingsInsteadOfMargins) {
          applyIfNotNull({
            padding-left: definition.retireFromIt.x,
            padding-top: definition.retireFromIt.y
          })
        } else {
          applyIfNotNull({
            margin-left: definition.retireFromIt.x,
            margin-top: definition.retireFromIt.y
          })
        }
      }
    }

    if (isNotNull(definition.pushItFromSelf) && (isNotNull(definition.pushItFromSelf.x) || isNotNull(definition.pushItFromSelf.y))) {

      // [ Example ]
      //    targetElementSelector: "h3"
      //    contextSelector: "EmailFormatting"
      //    referenceElementSelector: "p"
      // we need:
      //    .EmailFormatting p + 3
      elementFromWhichToRetireSelector = isNull(contextSelector) ?\
          referenceElementSelector : contextSelector + " " + referenceElementSelector

      /{elementFromWhichToRetireSelector} + {targetElementSelector} {
        if (definition.pushItFromSelf.usePaddingsInsteadOfMargins) {
          applyIfNotNull({
            padding-left: definition.pushItFromSelf.x,
            padding-top: definition.pushItFromSelf.y
          })
        } else {
          applyIfNotNull({
            margin-left: definition.pushItFromSelf.x,
            margin-top: definition.pushItFromSelf.y
          })
        }
      }
    }
  })


retireFrom(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      targetElementSelector: {
        type: DataTypes.string,
        requiredIf: {
          predicate: @(parametersObject) { return isNull(parametersObject.definitions) },
          descriptionForLogging: "The 'definitions' are not specified"
        }
      },
      x: {
        type: DataTypes.unit,
        required: false
      },
      y: {
        type: DataTypes.unit,
        required: false
      },
      usePaddingsInsteadOfMargins: {
        type: DataTypes.boolean
      },
      definitions: {
        required: false,
        incompatibleWith: "targetElementSelector" "x" "y" "usePaddingsInsteadOfMargins"
      },
      contextSelector: {
        type: DataTypes.string,
        required: false
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "retireFrom"
  })

  if (isNotNull(parametersObject.definitions)) {

    iterateAssociativeArray(parametersObject.definitions, @(targetElementSelector, definition) {

      definition.retireFromIt = {
        x: definition.x,
        y: definition.y,
        usePaddingsInsteadOfMargins: definition.usePaddingsInsteadOfMargins
      }

      /* [ Approach ] Delete became unnecessary properties */
      definition.x = null
      definition.y = null
      definition.usePaddingsInsteadOfMargins = null
    });

    definitions = parametersObject.definitions

  } else {
    definitions = (\
      parametersObject.targetElementSelector\
      {
        retireFromIt: { x: parametersObject.x, y: parametersObject.y },
        usePaddingsInsteadOfMargins: parametersObject.usePaddingsInsteadOfMargins
      }
    )
  }

  PositionalRelationship({
    definitions: definitions,
    contextSelector: parametersObject.contextSelector,
    referenceElementSelector: parametersObject.referenceElementSelector
  })


pushTargetFromSelf(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      targetElementSelector: {
        type: DataTypes.string,
        requiredIf: {
          predicate: @(parametersObject) { return isNull(parametersObject.definitions) },
          descriptionForLogging: "The 'definitions' are not specified"
        }
      },
      x: {
        type: DataTypes.unit,
        required: false
      },
      y: {
        type: DataTypes.unit,
        required: false
      },
      usePaddingsInsteadOfMargins: {
        type: DataTypes.boolean
      },
      definitions: {
        required: false,
        incompatibleWith: "targetElementSelector" "x" "y" "usePaddingsInsteadOfMargins"
      },
      contextSelector: {
        type: DataTypes.string,
        required: false
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "pushTargetFromSelf"
  })

  if (isNotNull(parametersObject.definitions)) {

    iterateAssociativeArray(parametersObject.definitions, @(targetElementSelector, definition) {

      definition.pushItFromSelf = {
        x: definition.x,
        y: definition.y,
        usePaddingsInsteadOfMargins: definition.usePaddingsInsteadOfMargins
      }

      /* [ Approach ] Delete became unnecessary properties */
      definition.x = null
      definition.y = null
      definition.usePaddingsInsteadOfMargins = null
    });

    definitions = parametersObject.definitions

  } else {
    definitions = (\
      parametersObject.targetElementSelector\
      {
        pushItFromSelf: { x: parametersObject.x, y: parametersObject.y },
        usePaddingsInsteadOfMargins: parametersObject.usePaddingsInsteadOfMargins
      }
    )
  }

  PositionalRelationship({
    definitions: definitions,
    contextSelector: parametersObject.contextSelector,
    referenceElementSelector: parametersObject.referenceElementSelector
  })


retireFromElementWithSameSelector(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      x: {
        type: DataTypes.unit,
        required: false
      },
      y: {
        type: DataTypes.unit,
        required: false
      },
      usePaddingsInsteadOfMargins: {
        type: DataTypes.boolean
        defaultValue: false
      },
      contextSelector: {
        type: DataTypes.string,
        required: false
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "retireFromElementWithSameSelector"
  })

  PositionalRelationship({
    definitions: (referenceElementSelector {
      retireFromIt: {
        x: parametersObject.x,
        y: parametersObject.y,
        usePaddingsInsteadOfMargins: parametersObject.usePaddingsInsteadOfMargins
      }
    }),
    contextSelector: parametersObject.contextSelector,
    referenceElementSelector: parametersObject.referenceElementSelector
  })


whenItJustAfter(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      targetElementSelector: {
        type: DataTypes.string,
        required: true
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "whenItJustAfter"
  })


  /{parametersObject.targetElementSelector} + {parametersObject.referenceElementSelector}

    {block}


whenTargetGoingJustAfterIt(parametersObject, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      targetElementSelector: {
        type: DataTypes.string,
        required: true
      },
      referenceElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "whenTargetGoingJustAfterIt"
  })


  /{parametersObject.referenceElementSelector} + {parametersObject.targetElementSelector}

    {block}


whenTargetWithSameSelectorGoingJustAfterIt(parametersObject = {}, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      targetElementSelector: {
        type: DataTypes.string,
        defaultValue: selector()
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "whenTargetWithSameSelectorGoingJustAfterIt"
  })


  /{parametersObject.targetElementSelector} + {parametersObject.targetElementSelector}

    {block}


whenItGoingFirst(parametersObject = {}, restParameters__MUST_NOT_BE...)

  validateSingleParametersObject({
    targetObject: parametersObject,
    propertiesSpecification: {
      verticalSpaceAbove: {
        type: DataTypes.unit
      }
    },
    restParameters: restParameters__MUST_NOT_BE,
    mixinOrFunctionName: "whenTargetWithSameSelectorGoingJustAfterIt"
  })


  &:first-child

    {block}

    applyIfNotNull({ margin-top: parametersObject.verticalSpaceAbove })


whenItGoingLast()

  &:last-child

    {block}
